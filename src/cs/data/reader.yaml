ExportKey: dataReaders
Version: 3
CanExport: true
ExportFileName: '{{model.Table.Name | UpperCamel | Plural }}DataReader.cs'
Groups: []
Tags: [cs]
Body: "using System;\r\nusing System.Collections.Generic;\r\nusing Microsoft.Data;\r\nusing System.Linq;\r\nusing {{model.Namespaces[\"api.models\"]}};\r\n\r\nnamespace {{model.Namespaces[\"dataReaders\"]}}\r\n{\r\n	public class {{model.Table.Name | UpperCamel | Singular}}DataReader : IDataReader\r\n	{\r\n\r\n      private int _currentIndex = 0;\r\n{%- for column in model.Table.Columns -%}{%- capture __count -%}{{forloop.length}}{%- endcapture -%}{% endfor %}\r\n        public {{model.Table.Name | UpperCamel | Singular}}DataReader(){}\r\n\r\n        public {{model.Table.Name | UpperCamel | Singular}}DataReader(List<{{model.Table.Name | UpperCamel | Singular}}> dataSource)\r\n        {\r\n            DataSource = dataSource;\r\n        }\r\n        public List<{{model.Table.Name | UpperCamel | Singular}}> DataSource { get; set; }\r\n\r\n\r\n        public int FieldCount => {{__count}};\r\n\r\n        public int GetOrdinal(string name)\r\n        {\r\n            switch (name)\r\n            {\r\n            {%- for column in model.Table.Columns -%}\r\n                case \"{{ column.Name }}\": return {{ forloop.index0 }};\r\n               {%- endfor -%}\r\n                default: return -1;\r\n            }\r\n        }\r\n\r\n        public object GetValue(int i)\r\n        {\r\n            switch (i)\r\n            {\r\n            {%- for column in model.Table.Columns -%}\r\n                case {{forloop.index0}}: return DataSource[_currentIndex].{{ column.PropertyName }};\r\n                {%- endfor -%}\r\n                default: return null;\r\n\r\n            }\r\n        }\r\n\r\n\r\n        \r\n        public bool Read()\r\n        {\r\n            if ((_currentIndex + 1) < DataSource.Count)\r\n            {\r\n                _currentIndex++;\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        #region Not needed for BulkInsert\r\n\r\n        public bool NextResult()\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public object this[int i] => throw new NotImplementedException();\r\n\r\n        public object this[string name] => throw new NotImplementedException();\r\n\r\n        public int Depth => throw new NotImplementedException();\r\n\r\n        public bool IsClosed => false; \r\n\r\n        public int RecordsAffected => DataSource.Count();\r\n\r\n        public void Close()\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public bool GetBoolean(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public byte GetByte(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public long GetBytes(int i, long fieldOffset, byte[] buffer, int bufferoffset, int length)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public char GetChar(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public long GetChars(int i, long fieldoffset, char[] buffer, int bufferoffset, int length)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public IDataReader GetData(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public string GetDataTypeName(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public DateTime GetDateTime(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public decimal GetDecimal(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public double GetDouble(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public Type GetFieldType(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public float GetFloat(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public Guid GetGuid(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public short GetInt16(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public int GetInt32(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public long GetInt64(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public string GetName(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        \r\n        public DataTable GetSchemaTable()\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public string GetString(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public int GetValues(object[] values)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n\r\n        public bool IsDBNull(int i)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n        #endregion\r\n                \r\n\r\n        #region IDisposable Support\r\n        private bool disposedValue = false; // To detect redundant calls\r\n\r\n        \r\n        protected virtual void Dispose(bool disposing)\r\n        {\r\n            if (!disposedValue)\r\n            {\r\n                if (disposing)\r\n                {\r\n                    DataSource = null;\r\n                }\r\n\r\n                disposedValue = true;\r\n            }\r\n        }\r\n\r\n        // ~TestReader() {\r\n        //   // Do not change this code. Put cleanup code in Dispose(bool disposing) above.\r\n        //   Dispose(false);\r\n        // }\r\n\r\n        // This code added to correctly implement the disposable pattern.\r\n        public void Dispose()\r\n        {\r\n            // Do not change this code. Put cleanup code in Dispose(bool disposing) above.\r\n            Dispose(true);\r\n            // TODO: uncomment the following line if the finalizer is overridden above.\r\n            // GC.SuppressFinalize(this);\r\n        }\r\n        #endregion\r\n	}\r\n}\r\n\r\n\r\n\r\n"
